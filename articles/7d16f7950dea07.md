---
title: "配列とオブジェクトの計算量の違い - O(n)とO(1)を理解する"
emoji: "💻"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["アルゴリズム", "Typescript", "初心者向け"]
published: false
---

## ことの発端

後で見るを別のオブジェクトで管理する案が上がった際、トップページに並ぶ動画の数だけ毎回配列から検索するとなると、「小さいとはいえ繰り返しアクセスする処理コストは気になる」という問題意識がありました。

ただそれは配列で作った場合O(n)であり、オブジェクトで作れば計算量はO(1)なのでデータ量の影響を受けない

## なぜ計算量が重要なのか
実際の開発では、このような「些細な違い」が大きな影響を与えることがあります。

**例えば：**
- トップページに1,000本の動画が表示される
- ユーザーが「後で見る」リストに100本の動画を保存している
- 各動画に「後で見る登録済み」のマークを表示したい

この場合：
- **配列で管理（O(n)）**: 1,000 × 100 = 100,000回の比較処理
- **オブジェクトで管理（O(1)）**: 1,000回のハッシュ検索

データ量が増えるほど、この差はどんどん大きくなっていきます。
ユーザーにとって快適なアプリを作るためには、データの管理方法を工夫することが大切

特にWebアプリケーションでは：
- **レスポンス速度**がユーザー満足度に直結
- **スケーラビリティ**（利用者増加への対応）が必要
- **リソース効率**（サーバーコスト削減）が求められる

## Big O notation

アルゴリズムの性能を記述するために使う表記
「O」は`オーダー(Order)`という単語に由来し、ランダウの記号などとも呼ばれ、
実行されるアルゴリズムがどれほどの時間、記憶領域を使用するかを評価するも基準として用いられる

### O(1) constant

命令数がデータ数に比例すること意味する
データ量と関係なく、処理時間が一定のオーダーで最も早い

### O(n) linear

データ量に応じて処理時間が比例するオーダー

他にも `O(log n)` `O(n log n)` などなど...

### 例) n の値までの合計を求める関数

```ts:o(1)の例
const n = 1_000_000_000

function oOne(n: number) {
    return n * (n + 1) / 2
}

const oOnestartTime = performance.now();
const oOnetotal = oOne(n)
const oOneendTime = performance.now();

console.log(`o(1) 合計: ${oOnetotal}`)
console.log(`o(1) 開始時間: ${oOnestartTime}`)
console.log(`o(1) 終了時間: ${oOneendTime}`)
console.log(`o(1) 処理時間: ${oOneendTime - oOnestartTime} ミリ秒`);
```

```ts:o(n)の例
const n = 1_000_000_000

function oN (n: number) {
    let sum = 0
    for (let i = 0; i <= n; i++) {
        sum += i
    }
    return sum
}

const oNstartTime = performance.now();
const oNtotal = oN(n)
const oNendTime = performance.now();

console.log(`o(n) 合計: ${oNtotal}`)
console.log(`o(n) 開始時間: ${oNstartTime}`)
console.log(`o(n) 終了時間: ${oNendTime}`)
console.log(`o(n) 処理時間: ${oNendTime - oNstartTime} ミリ秒`);
```

## O(1)のアルゴリズム

オブジェクトは ハッシュテーブル を利用して key と値を管理します。

![ハッシュテーブルの仕組み](https://storage.googleapis.com/zenn-user-upload/5def92ed605a-20250926.png)

```ts
const person = { name: "Taro", age: 20 };

console.log(person.age);
```

- "age" をハッシュ化して、格納先のメモリ位置を計算
- 計算結果から一発で値にアクセス
- 平均的な計算量は O(1)

```shell: 図解
"age" → ハッシュ化 → アドレスを特定 → [20]
```

## O(n)のアルゴリズム

配列は 順番に並んだデータの集まりで、インデックスで管理されています。

メモリ上のイメージ

```
index:  0   1   2   3   4   5
value: 10  20  40  30  50  90
```

- インデックス 0 から順番に調べる必要がある
- 最悪の場合、すべての要素を見る
- 時間計算量は O(n)

```ts
const arr = [10, 20, 40, 30, 50, 90];
const search = 30;

const find = arr.find((value) => {
  console.log(value);
  return value === search;
});
```

上記のログ、順番にチェックしている。

```shell
[LOG]: 10
[LOG]: 20
[LOG]: 40
[LOG]: 30
```

値(arr)の数が大きくなればなるほど比例して処理に時間がかかる

```shell: 図解
[10] → [20] → [40] → [30]
　↑　　　 ↑      ↑      ↑
順番にチェック
```

## 配列とオブジェクトのメリット・デメリット

#### 配列のメリット

- ループ処理が簡単 for, forEach, map, filter, find ...など
- 順序性がある
- メモリ効率が良い（連続したメモリ領域を使用）

#### オブジェクトのメリット

- key から素早くアクセス可能 → 平均的に O(1)
- データの存在チェックが高速 → key in obj ですぐ判定

#### 配列のデメリット

- 値の探索(find)、存在チェックに時間(includes)がかかる

#### オブジェクトのデメリット

- ループ処理を必要とする際、変換が必要
- 要素数を直接扱うことができない(length)など

## 実際の開発での使い分け

### 配列（O(n)）を選ぶ場面
- データに順序が重要
- すべての要素を順番に処理する場面が多い
- データ量が少ない（数十〜数百個程度）

### オブジェクト・Map（O(1)）を選ぶ場面
- 特定のキーで高速にアクセスしたい
- データの存在チェックを頻繁に行う
- データ量が大きい（数千個以上）
---

## Sample

```gql
query GET_WATCH_LATER_VIDEOS {
  me: {
    watchLaterVideos {
      uploadedVideoID
    }
  }
}
```

```ts
console.clear();
const obj = {
  data: {
    me: {
      watchLaterVideos: [
        {
          uploadedVideoID: 36,
        },
        {
          uploadedVideoID: 2147,
        },
        {
          uploadedVideoID: 2148,
        },
        {
          uploadedVideoID: 2181,
        },
        {
          uploadedVideoID: 2182,
        },
      ],
    },
  },
};

const videoId = 2182;
// O(n)の場合
const startTime = performance.now();
const watchLaterVideo = obj.data.me.watchLaterVideos.find(
  (video) => video.uploadedVideoID === videoId
);
console.log(watchLaterVideo);
const endTime = performance.now();
console.log(`o(n) 開始時間: ${startTime}`);
console.log(`o(n) 終了時間: ${endTime}`);
console.log(`o(n) 処理時間: ${endTime - startTime} ミリ秒`);

// O(1)の場合
const startTime2 = performance.now();
// Map Objectへ変換
const watchLaterVideoMap = new Map(
  obj.data.me.watchLaterVideos.map((video) => [video.uploadedVideoID, true])
);
console.log(watchLaterVideoMap);
console.log(watchLaterVideoMap.get(videoId));
const endTime2 = performance.now();
console.log(`o(1) 開始時間: ${startTime2}`);
console.log(`o(1) 終了時間: ${endTime2}`);
console.log(`o(1) 処理時間: ${endTime2 - startTime2} ミリ秒`);
```
